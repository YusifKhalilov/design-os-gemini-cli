description = "Create screen designs for a section of your product"
prompt = """
# Design Screen

You are helping the user create a screen design for a section of their product. The screen design will be a props-based React component that can be exported and integrated into any React codebase.

## Step 1: Check Prerequisites

First, identify the target section and verify that `spec.md`, `data.json`, and `types.ts` all exist.

Read `/product/product-roadmap.md` to get the list of available sections.

If there's only one section, auto-select it. If there are multiple sections, ask which section the user wants to create a screen design for.

Then verify all required files exist:

- `product/sections/[section-id]/spec.md`
- `product/sections/[section-id]/data.json`
- `product/sections/[section-id]/types.ts`

If spec.md doesn't exist:
"I don't see a specification for **[Section Title]** yet. Please run `/design-os:shape-section` first."

If data.json or types.ts don't exist:
"I don't see sample data for **[Section Title]** yet. Please run `/design-os:sample-data` first."

Stop here if any file is missing.

## Step 2: Check for Design System and Shell

Check for optional enhancements:

**Design Tokens:**
- Check if `/product/design-system/colors.json` exists
- Check if `/product/design-system/typography.json` exists

If design tokens exist, read them and use them for styling. If they don't exist, show a warning:
"Note: Design tokens haven't been defined yet. I'll use default styling, but for consistent branding, consider running `/design-os:design-tokens` first."

**Shell:**
- Check if `src/shell/components/AppShell.tsx` exists

If shell exists, the screen design will render inside the shell. If not, show a warning:
"Note: An application shell hasn't been designed yet. Consider running `/design-os:design-shell` first."

## Step 3: Analyze Requirements

Read and analyze all three files:

1. **spec.md** - Understand the user flows and UI requirements
2. **data.json** - Understand the data structure and sample content
3. **types.ts** - Understand the TypeScript interfaces and available callbacks

Identify what views are needed based on the spec. Common patterns:
- List/dashboard view (showing multiple items)
- Detail view (showing a single item)
- Form/create view (for adding/editing)

## Step 4: Clarify the Screen Design Scope

If the spec implies multiple views, confirm which view to build first:

"The specification suggests a few different views for **[Section Title]**:

1. **[View 1]** - [Brief description]
2. **[View 2]** - [Brief description]

Which view should I create first?"

If there's only one obvious view, proceed directly.

## Step 5: Create the Props-Based Component

Create the main component file at `src/sections/[section-id]/components/[ViewName].tsx`.

### Component Structure

The component MUST:
- Import types from the types.ts file
- Accept all data via props (never import data.json directly)
- Accept callback props for all actions
- Be fully self-contained and portable

### Design Requirements

- **Mobile responsive:** Use Tailwind responsive prefixes (`sm:`, `md:`, `lg:`)
- **Light & dark mode:** Use `dark:` variants for all colors
- **Use design tokens:** If defined, apply the product's color palette and typography
- **Create distinctive, memorable interfaces**

### What to Include

- Implement ALL user flows and UI requirements from the spec
- Use the prop data (not hardcoded values)
- Include realistic UI states (hover, active, etc.)
- Use the callback props for all interactive elements
- Handle optional callbacks with optional chaining: `onClick={() => onDelete?.(id)}`

### What NOT to Include

- No `import data from` statements - data comes via props
- No features not specified in the spec
- No routing logic - callbacks handle navigation intent
- No navigation elements (shell handles navigation)

## Step 6: Create Sub-Components (If Needed)

For complex views, break down into sub-components. Each sub-component should also be props-based.

Create sub-components at `src/sections/[section-id]/components/[SubComponent].tsx`.

## Step 7: Create the Preview Wrapper

Create a preview wrapper at `src/sections/[section-id]/[ViewName].tsx`.

This wrapper imports the sample data and feeds it to the props-based component.

The preview wrapper:
- Has a `default` export (required for Design OS routing)
- Imports sample data from data.json
- Passes data to the component via props
- Provides console.log handlers for callbacks (for testing)
- Is NOT exported to the user's codebase - it's only for Design OS

## Step 8: Create Component Index

Create an index file at `src/sections/[section-id]/components/index.ts` to export all components.

## Step 9: Confirm and Next Steps

"I've created the screen design for **[Section Title]**:

**Exportable components** (props-based, portable):
- `src/sections/[section-id]/components/[ViewName].tsx`
- `src/sections/[section-id]/components/[SubComponent].tsx` (if created)
- `src/sections/[section-id]/components/index.ts`

**Preview wrapper** (for Design OS only):
- `src/sections/[section-id]/[ViewName].tsx`

**Important:** Restart your dev server to see the changes.

**Next steps:**
- Run `/design-os:screenshot-design` to capture a screenshot of this screen design
- If the spec calls for additional views, run `/design-os:design-screen` again to create them
- When all sections are complete, run `/design-os:export-product` to generate the export package"

## Important Notes

- Components MUST be props-based - never import data.json in exportable components
- The preview wrapper is the ONLY file that imports data.json
- Use TypeScript interfaces from types.ts for all props
- Callbacks should be optional (use `?`) and called with optional chaining (`?.`)
- Always remind the user to restart the dev server after creating files
"""
